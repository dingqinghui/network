## Morn：排列组合

这里的排列组合就是你们所学过的：从口袋里拿球的问题，男生女生排排队问题，乒乓球捉对比赛问题，等等。

简单的讲，排列就是从m个数中有序的取出n个数，组合就是从m个数中无序的取出n个数，当然，m≥n。

Morn提供了排列组合的索引生产函数。

### 接口

#### 组合

```c
int mCombination(int *idx,int n,int m);
```

此函数解决从m个数中无序的取出n个数的索引问题，idx是组合数的索引输出，n是检出数量，m是总数量。

循环的执行此函数，将获得所有可能的组合索引。若所有的组合都已经被列出时，此函数将返回`MORN_FAIL`，否则返回`MORN_SUCCESS`。

例如：从5个数中，任取3个数。

```c
int idx[3];
for(int i=0;mCombination(idx,3,5)==MORN_SUCCESS;i++)
    printf("i=%d:idx=%d,%d,%d\n",i,idx[0],idx[1],idx[2]);
```

此段函数将输出：

```
i=0:idx=0,1,2
i=1:idx=0,1,3
i=2:idx=0,1,4
i=3:idx=0,2,3
i=4:idx=0,2,4
i=5:idx=0,3,4
i=6:idx=1,2,3
i=7:idx=1,2,4
i=8:idx=1,3,4
i=9:idx=2,3,4
```

如上，5取3共有10种组合。

另一个例子：现有1到10共10个数字，现要求从中取出4个数字，使得4数相加等于20。这时，可以使用如下程序：

```c
int main()
{
    int data[10] = {1,2,3,4,5,6,7,8,9,10};
    int idx[4];
    while(mCombination(idx,4,10)==MORN_SUCCESS)
    {
        int d0=data[idx[0]];int d1=data[idx[1]];int d2=data[idx[2]];int d3=data[idx[3]];
        if(d0+d1+d2+d3==20) printf("%d+%d+%d+%d==20\n",d0,d1,d2,d3);
    }
    return 0;
}
```

其执行结果为：

```
1+2+7+10==20
1+2+8+9==20
1+3+6+10==20
1+3+7+9==20
1+4+5+10==20
1+4+6+9==20
1+4+7+8==20
1+5+6+8==20
2+3+5+10==20
2+3+6+9==20
2+3+7+8==20
2+4+5+9==20
2+4+6+8==20
2+5+6+7==20
3+4+5+8==20
3+4+6+7==20
```

当然，这不是最简单的算法，这里只是演示`mCombination`函数怎么用。



#### 排列

```c
int mPermutation(int *idx,int n,int m);
```

此函数解决从m个数中无序的取出n个数的索引问题，idx是排列数的索引输出，n是检出数量，m是总数量。

循环的执行此函数，将获得所有可能的索引排列。若所有的排列都已经被列出时，此函数将返回`MORN_FAIL`，否则返回`MORN_SUCCESS`。

例如：从5个数中，任取3个数。

```c
int idx[3];
for(int i=0;mPermutation(idx,3,5)==MORN_SUCCESS;i++)
    printf("i=%d:idx=%d,%d,%d\n",i,idx[0],idx[1],idx[2]);
```

此段函数将输出：

```
i=0:idx=0,1,2
i=1:idx=0,1,3
i=2:idx=0,1,4
i=3:idx=0,2,1
...
i=56:idx=4,2,3
i=57:idx=4,3,0
i=58:idx=4,3,1
i=59:idx=4,3,2
```

如上，5取3共有60种排列。

另一个例子：平面上有随机的4个点，求解此4个点如何排列，其连线才能组成一个四边形？这时，可以使用如下程序：

```c
int main()
{
    MImagePoint p[4];
    for(int i=0;i<4;i++) {p[i].x=mRand(0,100);p[i].y=mRand(0,100);}
    printf("point:\n(%f,%f),(%f,%f),(%f,%f),(%f,%f)\n",p[0].x,p[0].y,p[1].x,p[1].y,p[2].x,p[2].y,p[3].x,p[3].y);
    MImagePoint *p0,*p1,*p2,*p3;
    p3=p+3;
    int idx[3];
    while(mPermutation(idx,3,3)==MORN_SUCCESS)
    {
        p0=p+idx[0];p1=p+idx[1];p2=p+idx[2];
        
        if((mLineCross(p0,p1,p2,p3,NULL)==0)&&(mLineCross(p0,p3,p1,p2,NULL)==0))
            printf("Quadrangle:\n(%f,%f),(%f,%f),(%f,%f),(%f,%f)\n",p0->x,p0->y,p1->x,p1->y,p2->x,p2->y,p3->x,p3->y);
    }
    return 0;
}
```

其执行结果为：

```
point:
(2.000000,62.000000),(56.000000,24.000000),(47.000000,52.000000),(61.000000,32.000000)
Quadrangle:
(56.000000,24.000000),(2.000000,62.000000),(47.000000,52.000000),(61.000000,32.000000)
Quadrangle:
(47.000000,52.000000),(2.000000,62.000000),(56.000000,24.000000),(61.000000,32.000000)
```

这里我固定了最后一个点的位置（不固定的话有8种方式），这时有两种排列方式（正时针和反时针）（题外话：如果是凹四边形的话未必只有两种排列方式）

