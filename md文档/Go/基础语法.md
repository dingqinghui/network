在函数中，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。

函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。



Go 在不同类型的项之间赋值时需要显式转换。表达式 `T(v)` 将值 `v` 转换为类型 `T`。

```go
i := 42
f := float64(i)
```



常量可以是字符、字符串、布尔值或数值。

常量不能用 `:=` 语法声明。





switch

Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。

```go
	switch 1.0 {
	case 1.0:
		fmt.Println("this is 1.0")
		fallthrough
	case 2.0:
		fmt.Println("this is 2.0")
	default:
		fmt.Println("this is default case")
	}
```





defer

defer 函数调用会被压入一个栈中。当外层函数返回时，**被推迟的函数会按照后进先出的顺序调用**



指针

go 没有指针的运算 p = p + 1(fail)



切片

保存底层指针，和切片基本信息

`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。

`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。

当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。



map

通过双赋值检测某个键是否存在：

```go
elem, ok = m[key]
```



空接口

空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）



chan

*注意：* 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。

*还要注意：* 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range` 循环。



## select 语句

`select` 语句使一个 Go 程可以等待多个通信操作。

`select` 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。