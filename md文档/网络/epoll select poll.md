## 1.select 底层原理 ：
select 将需要监视的文件描述符readfds/writefds/exceptfds拷贝到内核。内核轮训检测每个传入的描述符，时间出发进行标记，遍历完拷贝内核数据到用户态地址空间。由于内核用数组实现，描述符有最大数量限制。

## 2.poll 底层原理：
poll原理与select 一样，只是内核采用链表存储就绪事件，没有了最大句柄的限制。

## 3.epoll 底层原理：
epoll底层使用 红黑树+就绪链表来实现。epoll_ctl_add/modify/delete 操作红黑树进行添加/修改/删除。树上的每个节点都和设备(网卡)驱动建立回调关系。当事件触发设备(网卡)驱动回调，在回调中将触发的事件拷贝到就绪链表中。 epoll_wait检查链表是否为空，不是空直接将链表内容拷贝到传入的用户态地址。为空则等待。
![epoll.jpg](I:\md文档\课程学习笔记\网络\epoll select.assets\20140911103834_133.jpg)

### 3.1 LT ET模式
LT(level triger)水平触发: 例 读事件，只要句柄FD对应的缓冲区中有数据则会一直触发    **LT+大块读**
ET(edge triger)边缘触发：例 读事件，句柄FD对应的缓冲区 数据从无到有 触发一次，如果我们读数据没有读完 那么不会重复触发。 **ET + 循环读**
使用场景：
ET：**适合于小块数据的处理**，如果处理大块数据(包很大/传输太快)据ET需要循环读取，那么有可能一直处理这个事件，导致其他事件无法处理。
LT：**大块数据**， 如果频繁的发送小块数据 ，就会频繁触发epoll

## 4.epoll与select和poll比较
select poll： 两次数据复制，用户态数据->内核态数据->用户态数据
epoll：一次数据复制，直接将链表中已经触发的事件复制到用户态地址  内核态数据->用户态数据
![在这里插入图片描述](I:\md文档\课程学习笔记\网络\epoll select.assets\20181005171528280)

select poll 基于轮训，
epoll 由硬件触发回调，

**epoll是线程安全的，就绪队列用自旋锁，红黑树用互斥锁。**






