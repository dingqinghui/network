## 1.读写锁
读锁(共享锁)：并发读
写锁(互斥锁)：互斥写/读


## 2.全局锁
flush table with read local
数据库中的所有表加锁，对于任何表的数据更新结构更新都将阻塞。用于数据库备份，

## 3.表锁
### 3.1显示加锁
```sql
LOCK TABLES t_user READ/WRITE;
UNLOCK TABLES ;
```
lock tables t1 read, t2 write; 命令，则其连接写 t1、读写 t2 的语句都会被阻塞。同时，加锁连接在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能在unlock tables之前访问其他表。
### 3.2隐式加锁
```sql
SELECT * from t_user,moneylog
```
等价于
```sql
LOCK TABLES t_user READ,moneylog READ;
SELECT * from t_user,moneylog;
UNLOCK TABLES
```
每个sql都是一个事务，执行完sql自动进行提交。查询自动添加读锁,增删改自动添加写锁。

### 3.3总结
在执行事务前一次性获得所需要得所有表锁，事务提交后释放所有锁，避免了死锁，没有死锁所有锁没有超时时间。在事务执行过程中不允许操作其他表(应该也是为了避免死锁)。表锁是写优先，如果有大量的写操作，那么会导致读饥饿。
**表锁粒度大，并发性差，性能高，没有死锁。适用于读多写少。没有锁超时机制应避免事务长时间不提交占用锁。**

## 4.行锁
### 4.1显示加锁
```sql
#读锁
SELECT * from t_user LOCK IN SHARE MODE;
#写锁
SELECT * from t_user FOR UPDATE;
```
### 4.2隐式加锁
对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加写锁；
对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁。
在commit /rollback时释放所有锁。

### 4.3 innodb对行锁实现
行锁是加载索引上的，只有使用索引检索会使用行锁，否则会退化成表锁。
如果发生全表扫描会加表锁
两个链接操作不同行，但是是同一索引那么也会发生互斥(锁在索引上)

### 4.4 innodb意向锁
为了使行锁和表锁兼容，增加了意向锁。意向锁是表锁。
表A的加读行锁会自动的在表A上加读意向锁。这时如果在表A上添加写表锁，那么不用遍历整张表查看是否有与表锁冲突的行锁。只需要查看表A是否有意向锁。
其实意向锁就是为了解决，表锁与行锁互斥效率问题。

### 4.5 innodb间隙锁
**范围查询时***并请求共享或排他锁时*** **，对存在的行加行锁，对不存在的行加间隙锁。间隙锁会阻塞并发插入，造成等待，**应避免范围加锁产生的间隙锁**。防止幻读，以满足相关隔离级别的要求。


### 4.6 innodb死锁处理
**死锁避免：事务以相同的顺序获取锁
死锁检测：通过超时检测死锁
死锁恢复：发生死锁回滚写锁最少的事务
**

## 5.存储引擎对锁的支持
myisam：表级锁
innodb：表级锁 行级锁 默认使用行级锁

参考资料：
https://blog.51cto.com/u_15102934/2633897
https://zhuanlan.zhihu.com/p/29150809