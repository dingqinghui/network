
## 1.进程模型---状态机

![image-20210425143520156](https://i.loli.net/2021/04/29/56eiMuJ7ZGzdjO8.png)

状态 = 内存 + 寄存器

动作 = 指令/中断

状态1---动作1-->状态2



## 2.进程管理
fork ：状态机的拷贝
execve：
	可执行文件(ELF)装入内存,更新状态机的代码段数据段
	更改IP寄存器指向ELF的main函数
exit：状态机的销毁


## 3.进程调度
硬件产生时钟中断操作系统收到中断，保存当前运行环境到内存(线程/进程的堆栈)。调度算法选择一个进程/线程恢复运行环境（运行环境就是寄存器的值）。


### 3.1调度策略

轮询  

优先级调度

Linux complete fair scheduling(完全公平调度)  : **每次选择运行时间最小的运行**  

fork时继承vruntime

sleep 导致vruntime 严重落后，可能导致sleep的进程获得长时间的时间片，所以wakeup时将vruntime改变为当前最小的

每次加不同的vruntime 实现优先级

红黑树实现vruntime

优先级翻转  互斥锁导致高优先级等待低优先级，低优先级获得更多的执行时间